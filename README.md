# Grid

## Преглед на задачата

Трябва да напишете програма, която да симулира компютърната игра **GRID** под номера на команди. Във всяко състезание могат да да участват различен брой шофьори и всеки шофьор ... ами, кара кола. Шофьорите имат различно отношение към пистата и автомобилите имат различни спецификации, което прави състезанието вълнуващо!

## Структура

### `Driver`

Всички шофьори имат име, общо време и кола за шофиране:

* `Name` – символен низ
* `TotalTime` – реално число
* `Car` – параметър от тип Car
* `FuelConsumptionPerKm –` реално число
* `Speed –` реално число
    Скоростта на шофьора се изчислява по формулата по-долу. Имайте предвид, че скоростта се променя на всяка обиколка.
    ```
    Speed = (car’s Hp + tyre’s degradation) / car’s fuelAmount
    ```

#### `AggressiveDriver`

Този тип водачи имат FuelConsumptionPerKm равен на 2.7 литра. Също така скоростта му е умножена по 1.3.

#### `EnduranceDriver`

и тип водачи имат FuelConsumptionPerKm равен на 1.5 литра.

### `Car`

Всяка кола трябва да запази своите конски сили (`Hp`), количеството гориво и вида на гумите, които са в момента.

* `Hp` –  цяло число
* `FuelAmount` – реално число
* `Tyre` – параметър от тип `Tyre`

Максималният капацитет на горивния резервоар за всеки автомобил е `160` литра. Количеството гориво не може да стане по-голямо от максималния капацитет на резервоара. Ако ви се даде повече гориво, отколкото е необходимо, трябва да напълните резервоара до максимум и нищо друго не се случва.

Ако количеството гориво падне под `0` литра, трябва да направите изключение и водачът не може да продължи състезанието.

### `Tyre`

Всеки тип гума има различна твърдост. Също така има ниво на разграждане (деградация), което определя продъжителността на живота на гумата.

* `Name` – символен низ
* `Hardness` –  реално число
* `Degradation` – реално число [0 - 100]

Всяка гума започва с деградация 100 точки и пада надолу към 0. При всяка обиколка деградацията се намалява със стойността на твърдостта. Ако деградацията на гумата падне под 0 точки, гумата се взривява и водачът не може да продължи състезанието. Ако една гума се взриви, трябва да изхвърлите излючение.

#### `UltrasoftTyre`

Има допълнително свойство:

* `Grip` – положително реално число.

Името на гумата е "Ultrasoft".

При всяка обиколка деградацията пада с твърдостта си съчетана със сцеплението на гумата. Също така, този тип гума се взривява, когато разпадът на гумата падне под 30 точки.

#### `HardTyre`

Името на гумата е “Hard”.

## Бизнес логика

Всяко изпълнение на приложението симулира само едно състезание. В началото получавате информация за пистата (обиколки / дължина), след което състезателите са регистрирани. Началото на състезанието се отбелязва с първата команда `CompleteLaps`. Състезанието завършва, когато всички обиколки се извършват от състезателите.

### The Controller Class - `RaceTower`
Бизнес логиката на програмата трябва да бъде концентрирана около няколко команди. Внедрете клас, наречен `RaceTower`, който ще притежава главната функционалност, представена от тези публични методи:

```js
class RaceTower {
    /**
    * Инициализира общия брой обиколки и дължината на трасето
    *
    * @param {int} lapsNumber - брой обиколки
    * @param {int} trackLength - дължина на пистата
    * @return {void}
    */
    setTrackInfo(lapsNumber, trackLength)
    {
        // @TODO: Add some logic here …
    }

    /**
    * Създава състезател и го регистрира в състезанието. 
    * 
    * @param {Array} commandArgs
    * @param {string} commandArgs[0] type - "Aggressive" или "Endurance"
    * @param {string} commandArgs[1] name - driver name
    * @param {string} commandArgs[2] hp - Car HP
    * @param {string} commandArgs[3] fuelAmount
    * @param {string} commandArgs[4] tyreType
    * @param {string} commandArgs[5] tyreHardness
    * @param {string} [commandArgs[6]] grip - само ако tyreType е "Ultrasoft"
    * @return {void}
    */
    registerDriver(commandArgs)
    {
        // @TODO: Add some logic here …
    }
    
    /**
    * Кара състезателя да посети бокса при текущата обиколка
    *
    * @param {Array} commandArgs
    * @param {string} commandArgs[0] reasonToBox - "ChangeTyres" или "Refuel"
    * @param {string} commandArgs[1] driversName - driver name
    * @param {string} commandArgs[2] tyreType / fuelAmount - в зависимост от reasonToBox
    * @param {string} [commandArgs[3]] tyreHardness - ако reasonToBox === "ChangeTyres"
    * @param {string} [commandArgs[4]] grip - ако reasonToBox === "ChangeTyres" && tyreType === "Ultrasoft"
    * @return {void}
    */
    driverBoxes(commandArgs)
    {
        // @TODO: Add some logic here …
    }
    
    /**
    * Всички водачи продължават състезанието със зададения брой обиколки.
    *
    * @param {Array} commandArgs
    * @param {string} commandArgs[0] numberOfLaps
    * @return {string}
    */ 
    completeLaps(commandArgs)
    {
        // @TODO: Add some logic here …
    }
    
    /**
    * 
    * @return {string[]}
    */
    getLeaderboard()
    {
        // @TODO: Add some logic here …
    }
```

### Команди

Програмата изпълнява последователност от команди. Командите могат да бъдат:

* `RegisterDriver type name hp fuelAmount tyreType tyreHardness [grip]`
  
    Извиква метода `RaceTower.registerDriver()`

    > *Входните данни може да не са валидни. Ако не можете да създадете състезател с данните, просто го пропуснете.*

* `Leaderboard`

    Извиква метода `RaceTower.getLeaderboard()`

    На първия ред принтирайте:
    ```
    Lap {currentLap}/{totalLaps}
    ```
    На следващите редове всички състезателите трябва да се показват в реда на техния напредък в следния формат:
    ```
    {position} {driverName} {totalTime/failureReason}
    ```
    Състезателите трябва да бъдат подредени по общото време във възходящ ред. Всикчи състезатели с повреда трябва да бъдат принтирани след активните състезатели в реда на техния провал (последният неуспешен шофьор е на дъното).

* `CompleteLaps numberOfLaps`

    Извиква метода `RaceTower.completeLaps()`

    На всяка обиколка `TotalTime` на всеки водач трябва да се увеличи с резултата от следната формула:
    ```
    60 / (дължината на трасето / скоростта на състезателя)
    ```
    След всяка обиколка трябва да изпълните действията по-долу в същата последователност:

    1. Намалете количеството гориво на всеки състезател по следната формула:
        ```
        trackLength * driver’s fuelConsumptionPerKm
        ```

    1. Деградирайте гумата според вида й.

    Ако имате по-голям брой обиколки от броя на обиколките, останали в състезанието, трябва да върнете съобщение
    ```
    There is no time! On lap {current lap}.
    ```
    и да не увеличавате броя завършени обиколки.

* `Box reasonToBox driversName (tyreType | fuelAmount) [tyreHardness [grip]]`

    Извиква метода `RaceTower.driverBoxes()`

    Добавя 20 секунди към неговото време. При посещение на бокса състезателят може да смени гумите си с нови или да зареди с гориво.


#### DNF

Ако състезател спре поради някаква повреда, той вече не напредва в състезанието под командата CompleteLaps. 
Състезателите, които вече не се състезават, все още участват в дъното на класацията, в реда на техния провал 
(последният неуспешен шофьор е на дъното).
